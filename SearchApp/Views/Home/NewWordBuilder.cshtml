
@{
    Layout = null;
}

<!DOCTYPE html>

<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <title>NewWordBuilder</title>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.core.min.js"></script>
   
    <style>

        .controlPanel {
            background: white;
            padding-left: 0;
            padding-right: 0;
            -webkit-box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
            -moz-box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
            box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
        }

        #wordsList {
            height: 300px;
            overflow: auto;
        }
    </style>

</head>
<body>
    <div style="width:50%;float:left">
        <canvas id="canvas" width="500" height="500" class="controlPanel"> </canvas>


    </div>
    <div style="width:30%;float:right">
        <div>
            <div>
                <span>
                    <b>Select Scene:</b>
                    <select id="ddlSelectScene">
                        <option value="">--Select Scene--</option>
                    </select>
                </span>&nbsp;
            </div><br />
            <div>
                <span><b>Name:</b><input type="text" id="txtPuzzleName" /></span>&nbsp;
                <span><button id="btnSavePuzzle">Save Puzzle</button></span>
            </div>
        </div>
        <div>
            <div>
                <b>Select Puzzle:</b>
                <select id="ddlSelectPuzzle">
                    <option value="">--Select Puzzle--</option>
                </select>
            </div>
        </div>
        <div>
            <div>
                <hr />
            </div>
            <div>
                <div>
                    <b>Load Words:</b>
                    <select id="ddlSelectSceneWords">
                        <option value="">--Select Scene--</option>
                    </select>
                </div>
            </div>
        </div>
        <div>
            <div>
                <hr />
            </div>
            <div>
                <div>
                    <b>ID:</b><input type="text" size="3" id="rectId"/>
                </div>
                <div>
                    <b>Width:</b><input type="text" size="3" id="boxWidth"/>
                </div>
                <div>
                    <b>Height:</b><input type="text" size="3" id="boxHeight"/>
                </div>
                <div>
                    <textarea id="txtWords" rows="10" cols="30"></textarea>
                </div>
                <div>
                    <button id="btnUpdatePuzzleWords">Update Puzzle</button>
                </div>
            </div>
            <div>
                <hr />
            </div>
        </div>
        <div>
            <input type="checkbox" name="chkMoveCanvas" value="canvasMove" id="chkMoveCanvas" /> Move Canvas
        </div>
        <div>
            <textarea id="txtCodes" rows="4" cols="30"></textarea>
        </div>
        <div id="wordsList">

        </div>
    </div>
    
        <script>
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext("2d");
            let scenesCollection = [];
            let wordsCollection = [];
            let sceneModel = null;
            let mouseIsDown = false;

          
            const Point2D = function (x, y) {
                return {
                    x: x,
                    y: y
                };
            };
            let initialDown = new Point2D(0, 0);
            canvas.onmouseup = function (evt) {
                mouseIsDown = false;
               
            };
            canvas.onmousemove = (evt) => {
               
                if ($('#chkMoveCanvas').is(":checked") && mouseIsDown) {
                    const pt = getMousePos(evt);
                    let deltaX = pt.x - initialDown.x;
                    let deltaY = pt.y - initialDown.y;
                    initialDown = new Point2D(pt.x, pt.y);
                    updateRects(deltaX, deltaY);
                    updateHighlightedWords();
                    const rectData = scenesCollection.find(x => x.type === 'puzzleData').data;
                    loadLettersCanvas(rectData);

                }
            };
            canvas.onmousedown = (e) => {
                const currPos = getMousePos(e);
                initialDown = new Point2D(currPos.x, currPos.y);
                mouseIsDown = true;
            }
            $('#btnSavePuzzle').click(function () {
                postPuzzleData();
               // loadSceneData('http://localhost:5233/Data/GetSavedPuzzles', 'scenes', loadDDLComponent('ddlSelectScene'));
            });

            buildWordGrid = () => {
                let mod = +scenesCollection.find(x => x.type === 'puzzleData').data.Modulus + 1;
                const rectData = scenesCollection.find(x => x.type === 'puzzleData').data.AllLetters;
                const plan = scenesCollection.find(x => x.type === 'puzzleData').data.Plan;
                let startId = parseInt($('#rectId').val());
                const boxWidth = parseInt($('#boxWidth').val());
                const boxHeight = parseInt($('#boxHeight').val());
                const wordsArr = $('#txtWords').val().toLocaleUpperCase().split('\n');
                //lets build an array of all ids in the box
                const boxIds = [];
                let indexCol = 0;
                let indexRow = 0;
                while (indexCol < boxWidth) {
                    let vertical = startId;
                    while (indexRow < boxHeight) {  
                        boxIds.push(vertical++);
                        indexRow++;
                    }
                    indexCol++;
                    indexRow = 0;
                    startId += mod;
                }
                const trials = 3;
                
                const placedOn = {};
                const wordsNotPlaced = [];
                const wordsPlaced = [];
                mod = +scenesCollection.find(x => x.type === 'puzzleData').data.Modulus
                wordsArr.forEach(word => {
                    let ticks = 0;
                    copyCollectIndex = [];

                     while (ticks < trials) {
                         const pickIndex = Math.floor((Math.random() * boxIds.length - 1));
                         const pickId = boxIds[pickIndex];
                          
                         if (!placedOn[pickId] && !wordsPlaced.some(val => val === word)) {
                                const pickDirection = Math.floor(Math.random() * (9 - 0) + 0);
                                const { collectIndxs } = stickOnPuzzle(word, pickDirection, rectData, mod, pickId, false);
                             // debugger;
                             let notFound = true;
                                collectIndxs.forEach(id => {
                                    if (placedOn[id]) notFound = false;
                                });
                             copyCollectIndex = collectIndxs;
                             if (notFound) {
                                    positions = [];
                                    copyCollectIndex.forEach(id => placedOn[id] = 1);
                                    placedOn[pickIndex] = 1;
                                    const { startRect, pickedRect, collectIndxs } = stickOnPuzzle(word, pickDirection, rectData, mod, pickId);
                                 const { sideLeftPos, sideRightPos, topPoints, bottomPoints } = calcWordsOutline(plan.Font, pickDirection, plan.Spacing, startRect, pickedRect);
                                 collectIndxs.forEach(id => {
                                     positions.push(retreivePos(id, rectData));
                                 })
                                        wordsCollection.push({
                                            ID: pickId,
                                            Word: word,
                                            Direction: pickDirection,
                                            LeftWall: sideLeftPos,
                                            RightWall: sideRightPos,
                                            TopWall: topPoints,
                                            BottomWall: bottomPoints,
                                            AllWordLocations: positions
                                        });
                                    wordsPlaced.push(word);
                                }
                            }
                            ticks++;
                    }
                });
               
                console.log('Array of Ids =>' , boxIds);
            }
            $('#btnUpdatePuzzleWords').click(function () {
                buildWordGrid();
                const rectData = scenesCollection.find(x => x.type === 'puzzleData').data;
                loadLettersCanvas(rectData);
                addWordsDom();
            });

            $("#txtCodes").keyup(function (event) {
                if (event.keyCode === 13) {
                    console.log('Text Area =>', $('#txtCodes').val());
                    parser($('#txtCodes').val());
                    const rectData = scenesCollection.find(x => x.type === 'puzzleData').data;
                    loadLettersCanvas(rectData);
                    addWordsDom();
                    saveContentStream();
                    

                }
            });
            const updateHighlightedWords = () => {
                const rectData = scenesCollection.find(x => x.type === 'puzzleData').data.AllLetters;
                const mod = scenesCollection.find(x => x.type === 'puzzleData').data.Modulus;
                const plan = scenesCollection.find(x => x.type === 'puzzleData').data.Plan;
                wordsCollection.forEach(w => {
                    const { startRect, pickedRect } = stickOnPuzzle(w.Word, w.Direction, rectData, mod, w.ID);
                    const { sideLeftPos, sideRightPos, topPoints, bottomPoints } = calcWordsOutline(plan.Font, w.Direction, plan.Spacing, startRect, pickedRect);
                    w.LeftWall = sideLeftPos;
                    w.RightWall = sideRightPos;
                    w.TopWall = topPoints;
                    w.BottomWall = bottomPoints;
                });
            }
            const getMousePos = (evt) => {
                var rect = canvas.getBoundingClientRect();

                //return new vector2d(evt.clientX - rect.left,evt.clientY - rect.top,-1,-1);
                return new Point2D(evt.clientX - rect.left, evt.clientY - rect.top);
            }
            const updateRects = (deltaX, deltaY) => {
                const rectData = scenesCollection.find(x => x.type === 'puzzleData').data.AllLetters;
                rectData.forEach(rect => {
                    rect.Position.x = rect.Position.x + deltaX;
                    rect.Position.y = rect.Position.y + deltaY;
                });
            }
            const saveContentStream = async () => {
                const postBody = { dataDump: $('#txtCodes').val() };
                const config = {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(postBody)
                }
                const fetchResponse = await fetch('http://localhost:5233/Data/SaveContentStream', config);
            }
            const postPuzzleData = async () => {
                const rectData = scenesCollection.find(x => x.type === 'puzzleData').data.AllLetters;
                const sceneData = scenesCollection.find(x => x.type === 'sceneData')?.data;
                const mod = scenesCollection.find(x => x.type === 'puzzleData').data.Modulus;
                const newWordArr = wordsCollection.map(item => {
                    return {
                        Word: item.Word,
                        Direction: item.Direction,
                        ID: item.ID,
                        Positions: item.AllWordLocations
                    }
                });
                const realPuzzleName = (sceneData && sceneData.PuzzleName) ? sceneData.PuzzleName : $('#ddlSelectPuzzle').val();
                const puzzleBody = {
                    SceneName: $('#txtPuzzleName').val(),
                    PuzzleName: $('#txtPuzzleName').val() + '#' + realPuzzleName,
                    Words: newWordArr,
                    Mod: mod
                };
                let postObject = { pixels: rectData, name: $('#txtPuzzleName').val() + '#' + realPuzzleName };
                const config = {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(puzzleBody)
                }
                const configPixels = {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(postObject)
                }
                const fetchResponse = await fetch('http://localhost:5233/Data/SaveNewScene', config);
                const postResponse = await fetch('http://localhost:5233/Data/SaveNewPuzzle', configPixels);
                const data = await fetchResponse.json();
            }
            const generateRandomLetters = () => {
                let alphabet = [
                    'A',
                    'B',
                    'C',
                    'D',
                    'E',
                    'F',
                    'G',
                    'H',
                    'I',
                    'J',
                    'K',
                    'L',
                    'M',
                    'N',
                    'O',
                    'P',
                    'Q',
                    'R',
                    'S',
                    'T',
                    'W',
                    'X',
                    'Y',
                    'Z'
                ];
                let letterPos = Math.floor((Math.random() * alphabet.length - 1));
                return alphabet[letterPos];
            }
            const randWord = (wordLen, iter) => {
                if (iter < wordLen) {
                    iter++;
                    return generateRandomLetters() + randWord(wordLen, iter);
                }
                return '';
            }
            const drawLines = (ptsLs) => {
                ptsLs.forEach((pt, index) => {
                    ctx.moveTo(pt.x, pt.y);
                    if (index + 1 < ptsLs.length) {
                        ctx.lineTo(ptsLs[index + 1].x, ptsLs[index + 1].y);
                    }
                });
            }
            const pullIDs = (word) => {
                collector = [];
                const rectData = scenesCollection.find(x => x.type === 'puzzleData').data.AllLetters;
                collector.push(word.ID);
                word.AllWordLocations.forEach(p => {
                    const r = rectData.find(f => f.Position.x === p.x && f.Position.y === p.y);
                    if (r) {
                        collector.push(r.ID);
                    }
                });
                return collector;
            }

            const addWordsDom = () => {
                $('#wordsList').empty();
                wordsCollection.forEach(wordItem => {
                    const $spanImg = $('<span style="margin-left:5px;" />');
                    const $spanWordTxt = $('<span>' + wordItem.Word + ',</span>');
                    const allIds = pullIDs(wordItem);
                    const rectIds = allIds.join(', ');
                    const $spanIDTxt = $('<span style="font-size:9px">' + rectIds + ',</span>');
                    const $spanDirectionTxt = $('<span>' + wordItem.Direction + ',</span>');
                    const $img = $('<img />');
                    const closureId = () => wordItem;
                    $spanImg.append($img);
                    $img.click(function () {
                        const myId = closureId();
                        console.log('Closure ID => ', myId);
                        const matchPos = wordsCollection.findIndex(word => word.ID === myId.ID);
                        
                        wordsCollection.splice(matchPos, 1);

                        const rectData = scenesCollection.find(x => x.type === 'puzzleData').data;
                        const mod = scenesCollection.find(x => x.type === 'puzzleData').data.Modulus;
                        console.log('The Old Word => ', myId.Word);
                        const replaceWord = randWord(myId.Word.length, 0);
                        console.log('Replace the word =>', replaceWord);
                        stickOnPuzzle(replaceWord, myId.Direction, rectData.AllLetters, mod, myId.ID);
                        loadLettersCanvas(rectData);
                        addWordsDom();

                    });
                    $img.attr('src', '/Content/images/cross-small.jpg');
                    $('#wordsList').append($spanWordTxt);
                    $('#wordsList').append($spanIDTxt);
                    $('#wordsList').append($spanDirectionTxt);
                    $('#wordsList').append($spanImg);
                    $('#wordsList').append('<hr />');

                });
                
            }
            const highlightWords = () => {
               // ctx.beginPath
                wordsCollection.forEach(w => {
                    drawLines(w.LeftWall);
                    drawLines(w.RightWall);
                    drawLines(w.TopWall);
                    drawLines(w.BottomWall);
                    ctx.stroke();
                });
               
                
            }
            const calcWordsOutline = (fontSize, direction, spacing, rectStart, rectEnd) => {
                let sideLeftPos = [];
                let sideRightPos = [];
                let topPoints = [];
                let bottomPoints = [];
                let calcPoints = null;

                switch (direction) {
                    case 0: //U
                        calcPoints = () => {
                            sideLeftPos = [
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y + spacing },
                                { x: rectStart.Position.x + fontSize + spacing, y: rectStart.Position.y + spacing }
                            ];
                            sideRightPos = [
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x + fontSize + spacing, y: rectEnd.Position.y - fontSize - spacing }
                            ];
                            topPoints = [
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y + spacing },
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y - fontSize - spacing }
                            ];
                            bottomPoints = [
                                { x: rectStart.Position.x + fontSize + spacing, y: rectStart.Position.y + spacing },
                                { x: rectEnd.Position.x + fontSize + spacing, y: rectEnd.Position.y - fontSize - spacing }
                            ];
                        } 
                        break;
                    case 1: //RU
                        calcPoints = () => {
                            sideLeftPos = [
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y + spacing },
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y - fontSize - spacing }
                            ];
                            topPoints = [
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y - fontSize - spacing },
                                { x: rectStart.Position.x + (fontSize / 2), y: rectStart.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x, y: rectEnd.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y - fontSize - spacing }
                            ];
                           sideRightPos = [
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y }
                            ];
                           
                            bottomPoints = [
                                { x: rectStart.Position.x - spacing , y: rectStart.Position.y  },
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y }
                            ];
                            
                        }
                        break;
                    case 2: //R
                        calcPoints = () => {
                            sideLeftPos = [
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y + spacing },
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y - fontSize - spacing }
                            ];
                            topPoints = [
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y - fontSize - spacing }
                 
                            ];
                            sideRightPos = [
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y }
                            ];

                            bottomPoints = [
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y }
                            ];

                        }
                        break;
                    case 3: //RD
                        calcPoints = () => {
                            sideLeftPos = [
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y + spacing },
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y - fontSize - spacing }
                            ];
                            sideRightPos = [
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y }
                            ];
                            
                            topPoints = [
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y - fontSize - spacing },
                                { x: rectStart.Position.x + (fontSize / 2), y: rectStart.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x, y: rectEnd.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y - fontSize - spacing }
                            ];
                            
                            bottomPoints = [
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y },
                                { x: rectStart.Position.x + (fontSize / 2), y: rectStart.Position.y },
                                { x: rectStart.Position.x + (fontSize / 2), y: rectStart.Position.y },
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y }
                            ];

                        }
                        break;
                    case 4: //D
                        calcPoints = () => {
                            sideLeftPos = [
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y + spacing }
                            ];
                            topPoints = [
                                { x: rectStart.Position.x - spacing, y: rectStart.Position.y - fontSize - spacing },
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y - fontSize - spacing }

                            ];
                            sideRightPos = [
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y + spacing}
                            ];

                            bottomPoints = [
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y + spacing },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y + spacing }
                            ];

                        }
                        break;
                    case 5: //LU
                        calcPoints = () => {
                            sideLeftPos = [
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y }
                            ];
                            sideRightPos = [
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y - fontSize - spacing },
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y }
                            ];

                            topPoints = [
                                { x: rectStart.Position.x + fontSize , y: rectStart.Position.y - fontSize - spacing },
                                { x: rectStart.Position.x + (fontSize / 2), y: rectStart.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x - spacing , y: rectEnd.Position.y - fontSize - spacing }
                            ];
                            
                            bottomPoints = [
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y },
                                { x: rectStart.Position.x + (fontSize / 2), y: rectStart.Position.y },
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y }
                            ];

                        }
                        break;
                    case 6: //L
                        calcPoints = () => {
                            sideLeftPos = [
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y + spacing }
                            ];
                            topPoints = [
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y - fontSize - spacing }

                            ];
                            sideRightPos = [
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y - fontSize - spacing },
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y + spacing }
                            ];

                            bottomPoints = [
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y + spacing },
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y + spacing }
                            ];
                            
                        }
                        break;
                    default: //LD
                        calcPoints = () => {
                            sideLeftPos = [
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y - fontSize },
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y }
                            ];
                            sideRightPos = [
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y - fontSize - spacing },
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y }
                            ];

                            topPoints = [
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y - fontSize - spacing },
                                { x: rectStart.Position.x, y: rectStart.Position.y - fontSize - spacing },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y - fontSize  },
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y - fontSize  }
                            ];
                            
                            bottomPoints = [
                                { x: rectStart.Position.x + fontSize, y: rectStart.Position.y },
                                { x: rectStart.Position.x + (fontSize / 2), y: rectStart.Position.y },
                                { x: rectEnd.Position.x + fontSize, y: rectEnd.Position.y },
                                { x: rectEnd.Position.x - spacing, y: rectEnd.Position.y }
                            ];
                            

                        }
                }
                calcPoints();
                return { sideLeftPos, sideRightPos, topPoints, bottomPoints };
            }
            const stickOnPuzzle = (word, direction, data, mod, pickedId, stickIt= true) => {
                let pickedIndx = pickedId;
                const startRect = data.find(x => x.ID === pickedId);
                let pickedRect = data.find(x => x.ID === pickedId);
                const collectIndxs = [];
                Array.prototype.forEach.call(word, (l, index) => {
                    if (stickIt)
                        pickedRect.Letter = l;

                    switch (direction) {
                        case 0:
                            pickedIndx -= 1; //U
                            break;
                        case 1:
                            pickedIndx += mod; //RU
                            break;
                        case 2:
                            pickedIndx += mod + 1; //R
                            break;
                        case 3:
                            pickedIndx += mod + 2; //RD
                            break;
                        case 4:
                            pickedIndx += 1; // D
                            break;
                        case 5:
                            pickedIndx -= mod + 2; // LU
                            break;
                        case 6:
                            pickedIndx -= mod + 1; // L
                            break;
                        default:
                            pickedIndx -= mod; //LD
                    }

                    if (index < word.length - 1) {
                        pickedRect = data.find(x => x.ID === pickedIndx);
                        collectIndxs.push(pickedIndx);
                    }
                });
                return { startRect, pickedRect, collectIndxs };
            }
            const loadBackgroundImg = () => {
                const img1 = new Image();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                //drawing of the test image - img1
                img1.onload = function () {
                    ctx.drawImage(img1, 0, 0);
                    const collectionData = scenesCollection.find(x => x.type === 'puzzleData');
                    if (collectionData) {
                        const rectData = collectionData.data;
                        loadLettersCanvas(rectData);
                    }
                   
                };
                img1.src = '/Content/images/baby-tiger.jpg';
            }
            const fillArray = (start, end) => {
                return Array(end - start + 1).fill().map((_, idx) => 'ID===' + (start + idx).toString());
            }
            const rebuildWords = (wordsLs) => {
                const mod = scenesCollection.find(x => x.type === 'puzzleData').data.Modulus;
                const rectData = scenesCollection.find(x => x.type === 'puzzleData').data.AllLetters;
                const plan = scenesCollection.find(x => x.type === 'puzzleData').data.Plan;
               
                wordsLs.forEach(w => {
                    positions = [];
                    const { startRect, pickedRect, collectIndxs } = stickOnPuzzle(w.Word, w.Direction, rectData, mod, w.ID);
                    const { sideLeftPos, sideRightPos, topPoints, bottomPoints } = calcWordsOutline(plan.Font, w.Direction, plan.Spacing, startRect, pickedRect);
                    collectIndxs.forEach(id => {
                        positions.push(retreivePos(id, rectData));
                    });
                    wordsCollection.push({
                        ID: w.ID,
                        Word: w.Word,
                        Direction: w.Direction,
                        LeftWall: sideLeftPos,
                        RightWall: sideRightPos,
                        TopWall: topPoints,
                        BottomWall: bottomPoints,
                        AllWordLocations: positions
                    });
                });
            }
            const retreivePos = (id, allLetters) => {
               
                const letter = allLetters.find(l => l.ID === id);
                return new Point2D(letter.OriginalPosition.x, letter.OriginalPosition.y);
            }
            const parser = (txtCommands) => {
               // txtCommands = txtCommands.replace(/[\n\r]+/g, '');
                const rectArr = txtCommands.split('\n').filter( val => val !== '');
                const rectData = scenesCollection.find(x => x.type === 'puzzleData').data.AllLetters;
                const plan = scenesCollection.find(x => x.type === 'puzzleData').data.Plan;
                let foundRect = null;
                rectArr.forEach(rectCmd => {
                    
                    const rectResult = rectCmd.split(':');
                    const rectId = rectResult[0];
                    if (rectResult[1].indexOf('WD') >= 0) {
                        const findWordArr = rectResult[1].replace('WD=', '').split(',');
                        const theWord = findWordArr[0].toUpperCase();
                        const beginId = parseInt(rectId.replace('ID===', ''));
                        const direction = parseInt(findWordArr[1].replace('D=', ''));
                        const mod = scenesCollection.find(x => x.type === 'puzzleData').data.Modulus;
                        const { startRect, pickedRect, collectIndxs } = stickOnPuzzle(theWord, direction, rectData, mod, beginId);
                        const { sideLeftPos, sideRightPos, topPoints, bottomPoints } = calcWordsOutline(plan.Font,direction, plan.Spacing,startRect, pickedRect);
                        //console.log(sideLeftPos, sideRightPos, topPoints, bottomPoints);
                        
                        positions = [];
                        positions.push(retreivePos(beginId, rectData));
                        collectIndxs.forEach(id => {
                            positions.push(retreivePos(id, rectData));
                        })
                        wordsCollection.push({
                            ID: beginId,
                            Word: theWord,
                            Direction: direction,
                            LeftWall: sideLeftPos,
                            RightWall: sideRightPos,
                            TopWall: topPoints,
                            BottomWall: bottomPoints,
                            AllWordLocations: positions

                        });
                        console.log(positions);
                    }
                    else {
                        let grpIds = [];
                        if (rectId.indexOf('-') > 0) {
                            const twoIds = rectId.split('-');
                            const beginLs = twoIds[0].split('=');
                            const endLs = twoIds[1].split('=');
                            const start = parseInt(beginLs[beginLs.length - 1]);
                            const end = parseInt(endLs[endLs.length - 1]);
                            grpIds = fillArray(start, end);
                        } else {
                            grpIds.push(rectId);
                        }
                        grpIds.forEach(justId => {
                            const rectActions = rectResult[1].split(',');

                            eval('foundRect = rectData.find(x => x.' + justId + ')');
                            rectActions.forEach(action => {
                                // debugger;
                                eval('foundRect.' + action);
                            });

                        });
                    }
                   
                });
            }
            const loadLettersCanvas = (data) => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.beginPath();
                ctx.save();
                data.AllLetters.forEach((rect) => {
                    if (rect.IsVisible) {
                        let strRgb = `rgba(${rect.BackgroundRed},${rect.BackgroundGreen},${rect.BackgroundBlue},1.0)`;
                        
                            ctx.fillStyle = strRgb;
                            let newY = rect.Position.y - data.Plan.Font;
                            const width = data.Plan.Font;
                            const height = data.Plan.Font;
                            ctx.fillRect(rect.Position.x, newY, width, height);
                            // ctx.stroke();

                        if (rect.Outline) {
                            // console.log(rect.letter, i);
                            let block = data.Plan.Font + data.Plan.Spacing;
                            ctx.rect(rect.Position.x, rect.Position.y - block, width, height);
                        }

                        strRgb = `rgba(${rect.Red},${rect.Green},${rect.Blue},1.0)`;
                        ctx.font = data.Plan.Style;
                        ctx.fillStyle = strRgb;
                        ctx.fillText(rect.Letter, rect.Position.x, rect.Position.y);
                        ctx.stroke();
                        // console.log(strRgb);
                    }
                });
                highlightWords();
                ctx.restore();
            }

            const loadDDLComponent = (uiId) => {
                return (serverData) => {
                    let selectScene = $('#' + uiId);
                    serverData.forEach(s => {
                        selectScene.append($('<option></option>').val(s).html(s));
                    });
                    if (uiId === 'ddlSelectScene') {
                        selectScene = $('#' + uiId + 'Words');
                        serverData.forEach(s => {
                            selectScene.append($('<option></option>').val(s).html(s));
                        });
                    }

                }
                
            }
            const loadWordsFromJson = () => {
                return (sceneData) => {
                    const wordsLs = sceneData.Words;
                    const originMod = +sceneData.Mod;
                    const currMod = +scenesCollection.find(x => x.type === 'puzzleData').data.Modulus;
                    const rectData = scenesCollection.find(x => x.type === 'puzzleData').data;
                    const plan = scenesCollection.find(x => x.type === 'puzzleData').data.Plan;
                    wordsLs.forEach(theWord => {
                        // debugger;
                        positions = [];
                        const position = Math.floor(theWord.ID / originMod);
                        const diff = theWord.ID - (position * originMod);
                        const newID = position * currMod + diff;

                        const { startRect, pickedRect, collectIndxs } = stickOnPuzzle(theWord.Word, theWord.Direction, rectData.AllLetters, currMod, newID);
                        const { sideLeftPos, sideRightPos, topPoints, bottomPoints } = calcWordsOutline(plan.Font, theWord.Direction, plan.Spacing, startRect, pickedRect);
                        /*collectIndxs.forEach(id => {
                            positions.push(retreivePos(id, rectData));
                        })*/
                        wordsCollection.push({
                            ID: newID,
                            Word: theWord.Word,
                            Direction: theWord.Direction,
                            LeftWall: sideLeftPos,
                            RightWall: sideRightPos,
                            TopWall: topPoints,
                            BottomWall: bottomPoints,
                            AllWordLocations: theWord.Positions
                        });
                    });
                     loadLettersCanvas(rectData);
                     addWordsDom();

                }
            }

            const wrapperReloadScene = (sceneData) => {
                return (puzzleData) => {
                    loadLettersCanvas(puzzleData);
                    rebuildWords(sceneData.Words);
                    addWordsDom();
                    highlightWords();
                }
              
            }
            const loadTxtComponent = (uiId) => {
                return (serverData) => {
                    $('#' + uiId).val(serverData.SceneName);
                    const url = 'http://localhost:5233/Data/GetLoadedScenePuzzle/?scenePuzzleName=' + $('#ddlSelectPuzzle').val();
                    sceneModel = serverData;
                    const justPuzzleName = serverData.PuzzleName.split('#')[1];
                    $('#ddlSelectPuzzle').val(justPuzzleName);
                    const puzzleUrl = 'http://localhost:5233/Data/GetLoadedScenePuzzle/?scenePuzzleName=' + serverData.SceneName + '&puzzleName=' + justPuzzleName;
                    loadSceneData(puzzleUrl, 'puzzleData', wrapperReloadScene(serverData));

                }
            }

            const loadSceneData = (endPt, typeId, callBackFunc)=> {
                const fetchScenes = fetch(endPt);
                fetchScenes.then(response => {
                    return response.json();
                }).then(data => {
                    if (typeId) {
                        if (scenesCollection.length > 0) {
                            scenesCollection[0] = {
                                type: typeId,
                                data: data
                            }
                        } else {

                            scenesCollection.push({
                                type: typeId,
                                data: data
                            });

                        }
                    }
                 
                    if (callBackFunc) {
                        callBackFunc(data);
                    }
                      

                });

            }
            $('#ddlSelectSceneWords').on('change', () => {
                if ($('#ddlSelectSceneWords').val() === '') {
                    return;
                }
                var url = 'http://localhost:5233/Data/GetLoadedSceneJson/?fileName=' + $('#ddlSelectSceneWords').val();
                wordsCollection = [];
                loadSceneData(url, '', loadWordsFromJson());

            });
            $('#ddlSelectScene').on('change', () => {
                if ($('#ddlSelectScene').val() === '') {
                    return;
                }
                var url = 'http://localhost:5233/Data/GetLoadedSceneJson/?fileName=' + $('#ddlSelectScene').val();
                wordsCollection = [];
                loadSceneData(url, 'sceneData', loadTxtComponent('txtPuzzleName'));
            });

            $('#ddlSelectPuzzle').on('change', () => {
                if ($('#ddlSelectPuzzle').val() === '') {
                    return;
                }
                var url = 'http://localhost:5233/Data/GetSinglePuzzle/?puzzleName=' + $('#ddlSelectPuzzle').val();
               
                loadSceneData(url, 'puzzleData', loadLettersCanvas);
            });

            loadSceneData('http://localhost:5233/Data/GetSavedPuzzles', 'scenes', loadDDLComponent('ddlSelectScene'));
            loadSceneData('http://localhost:5233/Data/GetPuzzleNames', 'puzzleNames', loadDDLComponent('ddlSelectPuzzle'));
           
        </script>
    </body>
   </html >
